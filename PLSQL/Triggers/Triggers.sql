------------------------------------------------------ Trigger para calcular el costo total de una reserva
CREATE OR REPLACE TRIGGER TR_CALC_TOTAL_RESERVA BEFORE
    INSERT OR UPDATE ON RESERVA FOR EACH ROW
DECLARE
    LV_COSTO ZONA_CONJUNTO.COSTO_ZONA%TYPE;
BEGIN
    SELECT
        COSTO_ZONA INTO LV_COSTO
    FROM
        ZONA_CONJUNTO ZC
    WHERE
        :NEW.COD_CONJUNTO = ZC.COD_CONJUNTO
        AND :NEW.COD_ZONA_CONJUNTO = ZC.COD_ZONA_CONJUNTO;
    :NEW.COSTO_TOTAL_RESERVA := :NEW.NUM_HORAS_RESERVADAS * LV_COSTO;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'TR_CALC_TOTAL_RESERVA Ha ocurrido un error: '
            || SQLCODE
            || SQLERRM);
END TR_CALC_TOTAL_RESERVA;
/

------------------------------------------------------ Trigger para actualizar el saldo de una cuenta de cobro dado un pago
CREATE OR REPLACE TRIGGER TR_PAGO_CUENTA BEFORE
    INSERT OR UPDATE ON PAGO FOR EACH ROW
DECLARE
    LC_ERROR INTEGER;
    LM_ERROR VARCHAR(150);
BEGIN
    PR_PAGAR_SALDO(:NEW.COD_CONJUNTO, :NEW.COD_BLOQUE, :NEW.COD_APARTAMENTO, :NEW.VALOR_PAGADO, LC_ERROR, LM_ERROR);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'TR_PAGO_CUENTA Ha ocurrido un error: '
            || SQLCODE
            || SQLERRM);
END TR_PAGO_CUENTA;
/

------------------------------------------------------ Trigger para insertar los datos correspondientes de pago a la tabla de auditoria.
CREATE OR REPLACE TRIGGER AUDIT_PAGO AFTER
    UPDATE OR INSERT ON PAGO FOR EACH ROW
DECLARE
    LK_AUDIT AUDIT_CUENTAS.COD_AUDIT_CUENTAS%TYPE;
BEGIN
    SELECT
        MAX(COD_AUDIT_CUENTAS) INTO LK_AUDIT
    FROM
        AUDIT_CUENTAS;
    IF LK_AUDIT IS NULL THEN
        LK_AUDIT := 1;
    ELSE
        LK_AUDIT := LK_AUDIT + 1;
    END IF;
    INSERT INTO AUDIT_CUENTAS (
        COD_AUDIT_CUENTAS,
        COD_CUENTA_COBRO,
        COD_PAGO,
        TABLA_MODIFICADA,
        FECHA_MODIFICACION,
        ESTADO_CUENTA,
        VALOR_PAGADO,
        USUARIO
    ) VALUES (
        LK_AUDIT,
        :NEW.COD_CUENTA_COBRO,
        :NEW.COD_PAGO,
        'PAGO',
        (SELECT CURRENT_TIMESTAMP FROM DUAL),
        NULL,
        :NEW.VALOR_PAGADO,
        (SELECT USER FROM DUAL)
    );
END AUDIT_CUENTA;
/

------------------------------------------------------ Trigger para calcular el saldo pendiente de una cuenta de cobro
CREATE OR REPLACE TRIGGER TR_SALDO_PENDIENTE BEFORE
    INSERT ON CUENTA_COBRO FOR EACH ROW
DECLARE
    LC_ERROR     INTEGER;
    LM_ERROR     VARCHAR(150);
    LS_PENDIENTE CUENTA_COBRO.SALDO_PENDIENTE%TYPE := 0;
BEGIN
    IF :NEW.PERIODO_MES_CUENTA = 1 THEN
        SELECT
            SUM(SALDO_ACTUAL + SALDO_PENDIENTE) INTO LS_PENDIENTE
        FROM
            CUENTA_COBRO
        WHERE
            PERIODO_MES_CUENTA = 12
            AND PERIODO_ANIO_CUENTA = :NEW.PERIODO_ANIO_CUENTA-1
            AND COD_APARTAMENTO = :NEW.COD_APARTAMENTO
            AND COD_BLOQUE = :NEW.COD_BLOQUE
            AND COD_CONJUNTO = :NEW.COD_CONJUNTO;
    ELSE
        SELECT
            SUM(SALDO_ACTUAL + SALDO_PENDIENTE) INTO LS_PENDIENTE
        FROM
            CUENTA_COBRO
        WHERE
            PERIODO_MES_CUENTA = :NEW.PERIODO_MES_CUENTA-1
            AND PERIODO_ANIO_CUENTA = :NEW.PERIODO_ANIO_CUENTA
            AND COD_APARTAMENTO = :NEW.COD_APARTAMENTO
            AND COD_BLOQUE = :NEW.COD_BLOQUE
            AND COD_CONJUNTO = :NEW.COD_CONJUNTO;
    END IF;
    IF LS_PENDIENTE IS NULL THEN
        :NEW.SALDO_PENDIENTE := 0;
    ELSE
        :NEW.SALDO_PENDIENTE := LS_PENDIENTE;
    END IF;
 -- PR_AUDITORIA_PAGO(:NEW.COD_CUENTA_COBRO, 0, :NEW.ESTADO_CUENTA, 0, LC_ERROR, LM_ERROR);
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'TR_SALDO_PENDIENTE Ha ocurrido un error: '
            || SQLCODE
            || SQLERRM);
END TR_SALDO_PENDIENTE;
/

------------------------------------------------------ Trigger para insertar los datos correspondientes de la cuenta de cobro a la tabla de auditoria.
CREATE OR REPLACE TRIGGER AUDIT_CUENTA AFTER
    UPDATE OR INSERT ON CUENTA_COBRO FOR EACH ROW
DECLARE
    LK_AUDIT AUDIT_CUENTAS.COD_AUDIT_CUENTAS%TYPE;
BEGIN
    SELECT
        MAX(COD_AUDIT_CUENTAS) INTO LK_AUDIT
    FROM
        AUDIT_CUENTAS;
    IF LK_AUDIT IS NULL THEN
        LK_AUDIT := 1;
    ELSE
        LK_AUDIT := LK_AUDIT + 1;
    END IF;
    INSERT INTO AUDIT_CUENTAS (
        COD_AUDIT_CUENTAS,
        COD_CUENTA_COBRO,
        COD_PAGO,
        TABLA_MODIFICADA,
        FECHA_MODIFICACION,
        ESTADO_CUENTA,
        VALOR_PAGADO,
        USUARIO
    ) VALUES (
        LK_AUDIT,
        :NEW.COD_CUENTA_COBRO,
        NULL,
        'CUENTA_COBRO',
        (SELECT CURRENT_TIMESTAMP FROM DUAL),
        :NEW.ESTADO_CUENTA,
        NULL,
        (SELECT USER FROM DUAL)
    );
END AUDIT_CUENTA;
/

------------------------------------------------------ Trigger para insertar el valor de administraci√≥n del conjunto en el detalle de una cuenta de cobro.
CREATE OR REPLACE TRIGGER TR_CONCEPTO_ADMIN BEFORE
    INSERT OR UPDATE ON DETALLE_CONCEPTO FOR EACH ROW
DECLARE
    LV_ADMIN CONJUNTO.BASE_ADMINISTRACION%TYPE;
    LC_ADMIN APARTAMENTO.COEF_ADMINISTRACION%TYPE;
BEGIN
    IF :NEW.COD_CONCEPTO = 1 THEN
        SELECT
            BASE_ADMINISTRACION,
            COEF_ADMINISTRACION INTO LV_ADMIN,
            LC_ADMIN
        FROM
            CONJUNTO     C,
            APARTAMENTO  A,
            CUENTA_COBRO CC
        WHERE
            CC.COD_APARTAMENTO = A.COD_APARTAMENTO
            AND CC.COD_BLOQUE = A.COD_BLOQUE
            AND CC.COD_CONJUNTO = A.COD_CONJUNTO
            AND A.COD_CONJUNTO = C.COD_CONJUNTO
            AND CC.COD_CUENTA_COBRO = :NEW.COD_CUENTA_COBRO;
        :NEW.PRECIO_CONCEPTO_CUENTA := LV_ADMIN + (LV_ADMIN * (LC_ADMIN / 100));
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'TR_CONCEPTO_ADMIN Ha ocurrido un error: '
            || SQLCODE
            || SQLERRM);
END;
/

------------------------------------------------------ Trigger para insertar los saldos por concepto en una cuenta
CREATE OR REPLACE TRIGGER TR_CONCEPTO_CUENTA BEFORE
    INSERT OR UPDATE ON DETALLE_CONCEPTO FOR EACH ROW FOLLOWS TR_CONCEPTO_ADMIN
DECLARE
    LS_ACTUAL    CUENTA_COBRO.SALDO_ACTUAL%TYPE;
    LS_PENDIENTE CUENTA_COBRO.SALDO_PENDIENTE%TYPE;
    LK_CONJUNTO  CONJUNTO.COD_CONJUNTO%TYPE;
    LK_BLOQUE    APARTAMENTO.COD_BLOQUE%TYPE;
    LK_APTO      APARTAMENTO.COD_BLOQUE%TYPE;
    LN_MES       CUENTA_COBRO.PERIODO_MES_CUENTA%TYPE;
    LN_ANIO      CUENTA_COBRO.PERIODO_ANIO_CUENTA%TYPE;
BEGIN
    SELECT
        SALDO_ACTUAL,
        SALDO_PENDIENTE,
        COD_CONJUNTO,
        COD_BLOQUE,
        COD_APARTAMENTO,
        PERIODO_MES_CUENTA,
        PERIODO_ANIO_CUENTA INTO LS_ACTUAL,
        LS_PENDIENTE,
        LK_CONJUNTO,
        LK_BLOQUE,
        LK_APTO,
        LN_MES,
        LN_ANIO
    FROM
        CUENTA_COBRO
    WHERE
        COD_CUENTA_COBRO = :NEW.COD_CUENTA_COBRO;
    IF LS_PENDIENTE < 0 THEN
        UPDATE CUENTA_COBRO
        SET
            SALDO_ACTUAL = (
                LS_ACTUAL + LS_PENDIENTE
            ) + :NEW.PRECIO_CONCEPTO_CUENTA,
            SALDO_PENDIENTE = 0
        WHERE
            COD_CUENTA_COBRO = :NEW.COD_CUENTA_COBRO;
        PR_INIT_SALDOS (LK_CONJUNTO, LK_BLOQUE, LK_APTO, LN_MES - 1, LN_ANIO);
    ELSE
        UPDATE CUENTA_COBRO
        SET
            SALDO_ACTUAL = LS_ACTUAL + :NEW.PRECIO_CONCEPTO_CUENTA
        WHERE
            COD_CUENTA_COBRO = :NEW.COD_CUENTA_COBRO;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'TR_CONCEPTO_CUENTA Ha ocurrido un error: '
            || SQLCODE
            || SQLERRM);
END;
/